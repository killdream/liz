// :: String -> String
function makeSymbol(a) {
  return makeString(a.toLowerCase()) }

// :: a, b -> Cons a b
function makeCons(a, b){
  return '{ head: ' + a + ', tail: ' + b + ' }' }

// :: [a] -> String
function makeVector(as) {
  return as.reduceRight(function(a, b) {
                          return makeCons(b, a) }, 'world["nil"]')}

// :: string, [a] -> string
function makeCall(n, as) {
  as = ['world'].concat(as)
  return "(" + n + ")(" + as.join(', ') + ")" }

// :: 

// :: [String], [String] -> String
function makeLambda(args, body) {
  var last = body.pop()
  var init = body.join(';\n')

  var restArg = args.pop()
  var posArgs = args[0]

  var posBindings = posArgs.map(function(n, i){
                                  return "world[" + n + "] = arguments[" + i + "]" })
  var restBindings = restArg? "world[" + restArg + "] = [].slice.call(arguments, " + posArgs.length + ")" : ''
  
  if (last) last  = "return " + last
  if (init) init += ";"

  return "(function(world) {\n"
       +    posBindings.join(';\n')     + ';\n'
       +    restBindings                + ';\n'
       +    init + last                 + ";\n"
       + "})" }

// :: String -> String
function makeString(a) { 
  return '"' 
       + a.replace(/\n/g, '\\n')
          .replace(/\r/g, '\\r')
          .replace(/"/g, '\\"') 
       + '"' }

ometa LizCompiler {
  args = []                   -> [[], null]
       | [[eval*:as]]         -> [as, null]
       | [[eval*:as] eval?:b] -> [as, b],
  
  strictEval = [#list [strictEval:hd eval*:tl]] -> makeCall(hd, tl)
             | [#id :a]                         -> { "world['" + a + "']" }
             | eval:a                           -> a,

  eval = [#id :a]                     -> makeString(a)
       | [#num :a]                    -> a
       | [#char :a]                   -> makeString(a)
       | [#sym :a]                    -> makeSymbol(a)
       | [#cons eval:a eval:b]        -> makeCons(a, b)
       | [#list [eval*:as]]           -> makeVector(as)
       | [#lambda args:as [eval*:bs]] -> makeLambda(as, bs)
       | [#eval strictEval:a]         -> a,

  cc = [strictEval*:as] -> as.join(';\n')
}
