// :: String -> String
function makeSymbol(a) {
  return makeString(a.toLowerCase()) }

// :: a, b -> Cons a b
function makeCons(a, b){
  return '{ head: ' + a + ', tail: ' + b + ' }' }

// :: [a] -> String
function makeVector(as) {
  return as.reduceRight(function(a, b) {
                          return makeCons(b, a) }, 'nil')}

// :: string, [a] -> string
function makeCall(n, as) {
  return "(" + n + ")(" + as.join(', ') + ")" }

// :: 

// :: [String], [String] -> String
function makeLambda(args, body) {
  return "vau([" + args[0].join(', ') + "], " + args[1] + ", " + makeVector(body) + ")" }

// :: String -> String
function makeString(a) { 
  return '"' 
       + a.replace(/\n/g, '\\n')
          .replace(/\r/g, '\\r')
          .replace(/"/g, '\\"') 
       + '"' }

ometa LizCompiler {
  args = []                   -> [[], null]
       | [[eval*:as]]         -> [as, null]
       | [[eval*:as] eval?:b] -> [as, b],
  
  strictEval = [#list [strictEval:hd eval*:tl]] -> makeCall(hd, tl)
             | [#id :a]                         -> { "lookup('" + a + "', world)" }
             | eval:a                           -> a,

  eval = [#id :a]                     -> makeString(a)
       | [#num :a]                    -> a
       | [#char :a]                   -> makeString(a)
       | [#sym :a]                    -> makeSymbol(a)
       | [#cons eval:a eval:b]        -> makeCons(a, b)
       | [#list [eval*:as]]           -> makeVector(as)
       | [#lambda args:as [eval*:bs]] -> makeLambda(as, bs)
       | [#eval strictEval:a]         -> a,

  cc = [strictEval*:as] -> as.join(';\n')
}
