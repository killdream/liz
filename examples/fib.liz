($define! def $define!)

;; -- Core operatives --------------------------------------------------
(def fn { | lexical-env formals . body |
         "Constructs a new lexically-scoped function."
         (wrap (eval (list* $vau formals (list* body))
                     lexical-env)) })

(def defn { | lexical-env symbol formals . body |
           "Binds a lexical function to a name in the environment."
           (def f (eval (list* fn formals body) lexical-env))
           (eval (list* def symbol (list* f)) lexical-env) })

(def if { | env test consequent alternate |
         ((eval test env) (eval consequent env)
                          (eval alternate env)) })

(def cond { | env . forms |
           (def test  (head forms))
           (def value (second forms))
           (def rest  (tail (tail forms)))
           (if (null? forms)  nil
               (if (eval test env)  (eval value env)
                   (eval (list* cond rest) env))) })
               

;; -- Helper -----------------------------------------------------------
(defn null? ((a))
  "Checks if a value is nil."
  (= a nil))

(defn second ((as))
  "Grabs the second value of a list."
  (head (tail as)))


;; -- The actual program -----------------------------------------------
(defn fib ((n))
  "Computes fibonacci. Recursive. And we don't have TCO :D"
  (cond (= n 0) 0
        (= n 1) 1
        #t      (+ (fib (- n 1)) (fib (- n 2)))))

(fib 10)